% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setupProject.R
\name{setupProject}
\alias{setupProject}
\alias{setupPaths}
\alias{setupSideEffects}
\alias{setupOptions}
\alias{setupModules}
\alias{setupPackages}
\alias{setupParams}
\alias{setupGitIgnore}
\title{Sets up a new or existing SpaDES project}
\usage{
setupProject(
  name,
  paths,
  modules,
  packages,
  times,
  options,
  params,
  sideEffects,
  require = NULL,
  restart = getOption("SpaDES.project.restart", FALSE),
  useGit = FALSE,
  setLinuxBinaryRepo = TRUE,
  standAlone = TRUE,
  libPaths = paths$packagePath,
  updateRprofile = getOption("Require.updateRprofile", FALSE),
  overwrite = FALSE,
  verbose = getOption("Require.verbose", 1L),
  envir = environment(),
  ...
)

setupPaths(
  name,
  paths,
  inProject,
  standAlone,
  libPaths,
  updateRprofile,
  overwrite,
  envir = environment(),
  verbose = getOption("Require.verbose", 1L),
  ...
)

setupSideEffects(
  name,
  sideEffects,
  paths,
  times,
  overwrite,
  envir = environment(),
  verbose = getOption("Require.verbose", 1L),
  ...
)

setupOptions(
  name,
  options,
  paths,
  times,
  overwrite,
  envir = environment(),
  verbose = getOption("Require.verbose", 1L),
  ...
)

setupModules(
  paths,
  modules,
  useGit,
  overwrite,
  envir = environment(),
  verbose = getOption("Require.verbose", 1L),
  ...
)

setupPackages(
  packages,
  modulePackages,
  require,
  libPaths,
  setLinuxBinaryRepo,
  standAlone,
  envir = environment(),
  verbose,
  ...
)

setupParams(
  name,
  params,
  paths,
  modules,
  times,
  overwrite,
  envir = environment(),
  verbose = getOption("Require.verbose", 1L),
  ...
)

setupGitIgnore(paths, envir = environment(), verbose, ...)
}
\arguments{
\item{name}{Optional. If supplied, the name of the project. If not supplied, an
attempt will be made to extract the name from the \code{paths[["projectPath"]]}.
If this is a GitHub project, then it should indicate the full Github
repository and branch name, e.g., \code{"PredictiveEcology/WBI_forecasts@ChubatyPubNum12"}}

\item{paths}{a list with named elements, specifically, \code{modulePath}, \code{projectPath},
\code{packagePath} and all others that are in \code{SpaDES.core::setPaths()}
(i.e., \code{inputPath}, \code{outputPath}, \code{scratchPath}, \code{cachePath}, \code{rasterTmpDir}).}

\item{modules}{a character string of modules to pass to \code{getModule}. These
should be in the form \code{GitHubAccount/Repo@branch} e.g.,
\code{"PredictiveEcology/Biomass_core@development"}. If the project is a git repository,
then it will not try to re-get these modules; instead it will rely on the user
managing their git status outside of this function.}

\item{packages}{Optional. A vector of packages that must exist in the \code{libPaths}.
This will be passed to \code{Require::Install}, i.e., these will be installed, but
not attached to the search path. See \code{require}.}

\item{times}{Optional. This will be returned if supplied; if supplied, the values
can be used in e.g., \code{params}, e.g., \code{params = list(mod = list(startTime = times$start))}.
See help for \code{SpaDES.core::simInit}.}

\item{options}{Optional. Either a named list to be passed to \code{options}
or a character vector indicating one or more file(s) to source,
in the order provided. These will be sourced into a temporary environment (not
the \code{.GlobalEnv}), so they will not create globally accessible objects. See details.}

\item{params}{Optional. Similar to \code{options}, however, this named list will be
returned, i.e., there are no side effects.}

\item{sideEffects}{Optional. This can be an expression or one or more filenames.
This/these will be parsed and evaluated, but nothing returned. This is intended
to be used for functions, such as cloud authentication or configurations,
that are run for their side effects only.}

\item{require}{Optional. A character vector of packages to install \emph{and} attach
(with \code{Require::Require}). These will be installed and attached at the start
of \code{setupProject} so that a user can use these during \code{setupProject}.}

\item{restart}{If the \code{projectPath} is not the current path, and the session is in
Rstudio, and interactive, it will restart with a new Rstudio session with a
new project, with a root path set to \code{projectPath}. Default is \code{FALSE}.}

\item{useGit}{A logical. If \code{TRUE}, it will use \verb{git clone}. Otherwise it will
get modules with \code{getModules}.}

\item{setLinuxBinaryRepo}{Logical. Should the binary RStudio Package Manager be used
on Linux (ignored if Windows)}

\item{standAlone}{A logical. Passed to \code{Require::standAlone}. This keeps all
packages installed in a project-level library, it \code{TRUE}. Default is \code{TRUE}.}

\item{libPaths}{A character vector. Passed to \code{Require::libPaths}, which will
in turn pass to \code{.libPaths(libPaths)}}

\item{updateRprofile}{Logical or Character string. If \code{TRUE}, then this
function will put several lines of code in the current directory's
\code{.Rprofile} file setting up the package libraries for this and future
sessions. If a character string, then this should be the path to an
\code{.Rprofile} file. To reset back to normal, run \code{setLibPaths()} without a
\code{libPath}. Default: \code{getOption("Require.updateRprofile", FALSE)}, meaning
\code{FALSE}, but it can be set with an option or within a single call.}

\item{overwrite}{Logical. Passed to \code{getModule}, and \code{setupParams}, \code{setupOptions}}

\item{verbose}{Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if \code{1} or TRUE, more outputs; \code{2} even more. NOTE: in
\code{Require} function, when \code{verbose >= 2}, the return object will have an
attribute: \code{attr(.., "Require")} which has lots of information about the
processes of the installs.}

\item{...}{Any other named objects a user might want.}

\item{inProject}{A logical. If \code{TRUE}, then the current directory is
inside the \code{paths[["projectPath"]]}.}

\item{modulePackages}{A named list, where names are the module names, and the elements
of the list are packages in a form that \code{Require::Require} accepts.}
}
\value{
\code{setupProject} will return a length-3 named list (\code{modules}, \code{paths}, \code{params}) that can be passed
directly to \code{SpaDES.core::simInit} using a \code{do.call}. See example.

\code{setupPaths} returns a list of paths that are created. It is also called for its
side effect which is to call \code{setPaths}, with each of these paths as an argument.
See table for details.

\code{setupSideEffects} is run for its side effects, with nothing returned to user.

\code{setupOptions} is run for its side effects, namely, changes to the \code{options()}.

\code{setupModules} is run for its side effects, i.e., downloads modules and puts them
into the \code{paths$modulePath}

\code{setupPackages} is run for its side effects, i.e., installing packages to
\code{paths$packagePath}.

\code{setupParams} is run for its side effects, namely, changes to the \code{options()}.

\code{setupGitIgnore} is run for its side effects, i.e., adding elements to the
\code{.gitignore} file.
}
\description{
\code{setupProject} calls a sequence of functions in this order:
\code{setupPaths}, \code{setupOptions},
\code{setupModules}, \code{setupPackages}, \code{setupTimes}, \code{setupParams},
\code{setupGitIgnore}. Because of this
order, settings in \code{options} can change \code{paths}, \code{times} can be used in \code{params},
for example.
This sequence will create folder structures, download or confirms
existence of modules, install missing
packages from both the modules \code{reqdPkgs} fields and the user passed
\code{packages}. See Details.
}
\details{
\code{setPaths} will fill in any paths that are not explicitly supplied by the
user as a named list. These paths that can be set are:
\code{projectPath}, \code{packagePath}, \code{cachePath}, \code{inputPath},
\code{modulePath}, \code{outputPath}, \code{rasterPath}, \code{scratchPath}, \code{terraPath}.
These are grouped thematically into three groups of paths:
\code{projectPath} and \code{packagePath} affect the project, regardless
of whether a user uses SpaDES modules. \code{cachePath}, \code{inputPath}, \code{outputPath} and
\code{modulePath} are all used by SpaDES within module contexts. \code{scratchPath},
\code{rasterPath} and \code{terraPath} are all "temporary" or "scratch" directories.

\code{setupSideEffects} can handle sequentially specified values, meaning a user can
first create a list of default options, then a list of user-desired options that
may or may not replace individual values. This can create hierarchies, \emph{based on
order}.

\code{setupOptions} can handle sequentially specified values, meaning a user can
first create a list of default options, then a list of user-desired options that
may or may not replace individual values. This can create hierarchies, \emph{based on
order}.

\code{setupModules} will download all modules do not yet exist locally. The current
test for "exists locally" is simply whether the directory exists. If a user
wants to update the module, \code{overwrite = TRUE} must be set, or else the user can
remove the folder manually.

\code{setupPackages} will read the modules' metadata \code{reqdPkgs} element. It will combine
these with any packages passed manually by the user to \code{packages}, and pass all
these packages to \code{Require::Install(...)}.

\code{setupGitIgnore} will add.
}
\section{Sequential evaluation}{

Throughout these functions, efforts have been made to implement sequential evaluation,
within files and within lists. This means that a user can \emph{use} the values from an
upstream element in the list. For example, the following is valid:

\if{html}{\out{<div class="sourceCode">}}\preformatted{paths = list(projectPath = "here", modulePath = file.path(paths[["projectPath"]], "modules")
}\if{html}{\out{</div>}}

Because of such sequential evaluation, \code{paths}, \code{options}, and \code{params} files
can be sequential lists that have impose a hierarchy specified
by the order. For example, a user can first create a list of \emph{default} options,
then several lists of user-desired options behind an \verb{if (user("emcintir"))}
block that add new or override existing elements, followed by \code{machine} specific
values, such as paths.
}

\section{Files for \code{paths}, \code{options}, \code{params}}{

If \code{paths}, \code{options} and/or \code{params} are a character string or vector, the string(s)
will be interpretted as files to parse. These files should contain R code that
specifies \emph{named lists}, where the names are one or more \code{paths}, \code{options},
or are module names, each with a named list of parameters for that named module.
This last named list for \code{params} follows the convention used for the \code{params} argument in
\code{simInit(..., params = )}. The \code{options} file should
not set \code{options} explicitly; only named lists. This enables options checking/validating
to occur within \code{setupOptions} and \code{setupParams}.

These files can use \code{paths}, \code{times}, plus any previous list in the sequence of
\code{params} or \code{options} specified.

A simplest case would be a file with this:
\code{opts <- list(reproducible.destinationPath = "~/destPath")}. All named lists will
be parsed into their own environment, and then will be sequentially evaluated (i.e.,
subsequent lists will have access to previous lists), with each named elements
setting or replacing the previously named element of the same name, creating a
single list. This final list will be assigned to \code{options()} inside \code{setupOptions}.
Because these are each parsed separately, it is not necessary to assign any list to
an object; and the objects, if named, can be any name, even the same name repeatedly.
The sequential nature means that a user can
have a named list of default settings first in the file, then those defaults can
be overridden by e.g., user-specific or machine-specific values that are
specified subsequently in the same file or in a separate file. Any functions
that are used must be available, e.g., prefixed \code{Require::normPath}.

NOTE: these will only parse items that are atomics (i.e., character, numeric, etc.),
named lists or either of these that are protected by 1 level of "if". This
will not work, therefore, for other side-effect elements, like authenticating
with a cloud service.

Several helper functions exist within \code{SpaDES.project} that may be useful, such
as \code{user(...)}, \code{machine(...)}
}

\section{Paths}{

\tabular{lll}{
\strong{Path}     \tab \strong{Default if not supplied by user} \tab Effects \cr
\tab \emph{Project Level Paths}   \tab \cr
\code{projectPath}\tab if \code{getwd()} is \code{name}, then just \code{getwd}; if not
\code{file.path(getwd(), name)}  \tab If current project is not this project
and using \code{Rstudio}, then the current
project will close and a new project will
open in the same Rstudio session, unless
\code{restart = FALSE}\cr
\code{packagePath}\tab \code{file.path(tools::R_user_dir("data"), name, "packages", version$platform, substr(getRversion(), 1, 3))}
\tab appends this path to \code{.libPaths(packagePath)},
unless \code{standAlone = TRUE}, in which case,
it will set \code{.libPaths(packagePath, include.site = FALSE)} to this path \cr
------       \tab -----------                 \tab  -----         \cr
\tab \emph{Module Level Paths}                 \tab \cr
\code{cachePath}  \tab \code{file.path(projectPath, "cache")} \tab \code{options(reproducible.cachePath = cachePath)}\cr
\code{inputPath}  \tab \code{file.path(projectPath, "input")} \tab \code{options(spades.inputPath = inputPath)}\cr
\code{modulePath} \tab \code{file.path(projectPath, "m")} \tab \code{options(spades.inputPath = outputPath)} \cr
\code{outputPath} \tab \code{file.path(projectPath, "output")} \tab \code{options(spades.inputPath = modulePath)} \cr
------       \tab -----------                 \tab  -----         \cr
\tab \emph{Temporary Paths}                 \tab  \cr
\code{scratchPath}\tab \code{file.path(tempdir(), name)} \tab \cr
\code{rasterPath} \tab \code{file.path(scratchPath, "raster")} \tab sets (\code{rasterOptions(tmpdir = rasterPath)}) \cr
\code{terraPath}  \tab \code{file.path(scratchPath, "terra")} \tab   sets (\code{terraOptions(tempdir = terraPath)})       \cr
------       \tab -----------                 \tab  -----         \cr
\tab \emph{Other Paths}                 \tab  \cr
\code{logPath}    \tab \code{file.path(outputPath(sim), "log")} \tab sets \code{options("spades.logPath")} accessible by \code{logPath(sim)}\cr
\code{tilePath}   \tab Not implemented yet \tab Not implemented yet \cr
}
}

\examples{
\dontrun{

setupProject() # simplest case; just creates folders, sets options in current folder

# set relative paths & modules
setupProject(name = "SpaDES.project",
             paths = list(modulePath = "m", projectPath = "SpaDES.project",
                          scratchPath = tempdir()),
             modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

# load packages using `require`
out <- SpaDES.project::setupProject(
  paths = list(projectPath = "~/CeresPaper"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require =
    c("PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
      "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"),
  modules = c("CeresBarros/Biomass_speciesData@master",
              "CeresBarros/Biomass_borealDataPrep@development",
              "CeresBarros/Biomass_core@master",
              "CeresBarros/Biomass_validationKNN@master",
              "CeresBarros/Biomass_speciesParameters@development")

  )

# With options and params set
out <- setupProject(name = "SpaDES.project",
             options = list(reproducible.useTerra = TRUE),
             params = list(Biomass_borealDataPrep = list(.plots = "screen")),
             paths = list(modulePath = "m", projectPath = "~/GitHub/SpaDES.project",
                          scratchPath = tempdir()),
             modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

# using an options file that is remote
out <- setupProject(name = "SpaDES.project",
             options = c("PredictiveEcology/LandWeb@development/04-options.R"),
             params = list(Biomass_borealDataPrep = list(.plots = "screen")),
             paths = list(modulePath = "m", projectPath = "~/GitHub/SpaDES.project",
                          scratchPath = tempdir()),
             modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

# using an options file that is remote
out <- setupProject(modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  sideEffects = system.file("sideEffects.R", package = "SpaDES.project",
  mode = "development")
)

# If using SpaDES.core, the return object can be passed to `simInit` via `do.call`
#   do.call(simInit, out)
}
}
\seealso{
\link{user}, \link{machine}, \link{node}
}
