% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setupProject.R
\name{setupProject}
\alias{setupProject}
\title{Sets up a new or existing SpaDES project}
\usage{
setupProject(
  name,
  paths,
  modules,
  packages,
  times,
  options,
  params,
  sideEffects,
  functions,
  config,
  require = NULL,
  studyArea = NULL,
  Restart = getOption("SpaDES.project.Restart", FALSE),
  useGit = getOption("SpaDES.project.useGit", FALSE),
  setLinuxBinaryRepo = getOption("SpaDES.project.setLinuxBinaryRepo", TRUE),
  standAlone = getOption("SpaDES.project.standAlone", TRUE),
  libPaths = NULL,
  updateRprofile = getOption("SpaDES.project.updateRprofile", TRUE),
  overwrite = getOption("SpaDES.project.overwrite", FALSE),
  verbose = getOption("Require.verbose", 1L),
  defaultDots,
  envir = parent.frame(),
  dots,
  ...
)
}
\arguments{
\item{name}{Optional. If supplied, the name of the project. If not supplied, an
attempt will be made to extract the name from the \code{paths[["projectPath"]]}.
If this is a GitHub project, then it should indicate the full Github
repository and branch name, e.g., \code{"PredictiveEcology/WBI_forecasts@ChubatyPubNum12"}}

\item{paths}{a list with named elements, specifically, \code{modulePath}, \code{projectPath},
\code{packagePath} and all others that are in \code{SpaDES.core::setPaths()}
(i.e., \code{inputPath}, \code{outputPath}, \code{scratchPath}, \code{cachePath}, \code{rasterTmpDir}).
Each of these has a sensible default, which will be overridden but any user
supplied values.
See \link{setup}.}

\item{modules}{a character string of modules to pass to \code{getModule}. These
should be one of: simple name (e.g., \code{fireSense}) which will be searched for locally
in the \code{paths[["modulePath"]]}; or a GitHub repo with branch (\code{GitHubAccount/Repo@branch} e.g.,
\code{"PredictiveEcology/Biomass_core@development"}); or a character vector that identifies
one or more module folders (local or GitHub) (not the module .R script).
If the entire project is a git repository,
then it will not try to re-get these modules; instead it will rely on the user
managing their git status outside of this function.
See \link{setup}.}

\item{packages}{Optional. A vector of packages that must exist in the \code{libPaths}.
This will be passed to \code{Require::Install}, i.e., these will be installed, but
not attached to the search path. See also the \code{require} argument. To force skip
of package installation (without assessing modules), set \code{packages = NULL}}

\item{times}{Optional. This will be returned if supplied; if supplied, the values
can be used in e.g., \code{params}, e.g., \code{params = list(mod = list(startTime = times$start))}.
See help for \code{SpaDES.core::simInit}.}

\item{options}{Optional. Either a named list to be passed to \code{options}
or a character vector indicating one or more file(s) to source,
in the order provided. These will be parsed locally (not
the \code{.GlobalEnv}), so they will not create globally accessible objects. NOTE:
\code{options} is run 2x within \code{setupProject}, once before \code{setupPaths} and once
after \code{setupPackages}. This occurs because many packages use options for their
behaviour (need them set before e.g., \code{Require::require} is run; but many packages
also change \code{options} at startup. See details.
See \link{setup}.}

\item{params}{Optional. Similar to \code{options}, however, this named list will be
returned, i.e., there are no side effects.
See \link{setup}.}

\item{sideEffects}{Optional. This can be an expression or one or more file names or
a code chunk surrounded by \code{{...}}.
If a non-text file name is specified (e.g., \emph{not .txt or .R} currently),
these files will simply be downloaded, using their relative path as specified
in the github notation. They will be downloaded or accessed locally at that
relative path.
If these file names represent scripts (*.txt or .R), this/these will be parsed and evaluated,
but nothing is returned (i.e., any assigned objects are not returned). This is intended
to be used for operations like cloud authentication or configuration functions
that are run for their side effects only.}

\item{functions}{A set of function definitions to be used within \code{setupProject}.
These will be returned as a list element. If function definitions require non-base
packages, prefix the function call with the package e.g., \code{terra::rast}. When
using \code{setupProject}, the \code{functions} argument is evaluated after \code{paths}, so
it cannot be used to define functions that help specify \code{paths}.}

\item{config}{Still experimental linkage to the \code{SpaDES.config} package. Currently
not working.}

\item{require}{Optional. A character vector of packages to install \emph{and} attach
(with \code{Require::Require}). These will be installed and attached at the start
of \code{setupProject} so that a user can use these during \code{setupProject}.
See \link{setup}}

\item{studyArea}{Optional. If a list, it will be passed to
\code{geodata::gadm}. To specify a country other than the default \code{"CAN"},
the list must have a named element, \code{"country"}. All other named elements
will be passed to \code{gadm}. 2 additional named elements can be passed for
convenience, \code{subregion = "..."}, which will be grepped with the column
\code{NAME_1}, and \code{epsg = "..."}, so a user can pass an \code{epsg.io} code to
reproject the \code{studyArea}. See examples.}

\item{Restart}{Logical or character. If either \code{TRUE} or a character,
and if the \code{projectPath} is not the current path, and the session is in
RStudio and interactive, it will try to restart Rstudio in the projectPath with
a new Rstudio project. If character, it should represent the filename
of the script that contains the \code{setupProject} call that should be copied to
the new folder and opened. If \code{TRUE}, it will use the active file as the one
that should be copied to the new projectPath and opened in the Rstudio project.
If successful, this will create an RStudio Project file (and .Rproj.user
folder), restart with a new Rstudio session with that new project and with a root
path (i.e. working directory) set to \code{projectPath}. Default is \code{FALSE}, and no
RStudio Project is created.}

\item{useGit}{(if not FALSE, then experimental still). There are two levels at which a project
can use GitHub, either the \code{projectPath} and/or the \code{modules}. Any given
project can have one or the other, or both of these under git control. If "both",
then this function will assume that git submodules will be used for the \code{modules}.
A logical or \code{"sub"} for \emph{submodule}. If \code{"sub"}, then this function
will attempt to clone the identified \code{modules} \emph{as git submodules}. This will only
work if the \code{projectPath} is a git repository. If the project is already a git
repository because the user has set that up externally to this function call, then
this function will add the \code{modules} as git submodules. If it is not already,
it will use \verb{git clone} for each module. After git clone or submodule add are run,
it will run \verb{git checkout} for the named branch and then \verb{git pull}
to get and change branch for each module, according to its specification in
\code{modules}. If \code{FALSE}, this function  will download modules with \code{getModules}.
NOTE: \emph{CREATING} A
GIT REPOSITORY AT THE PROJECT LEVEL AND SETTING MODULES AS GIT SUBMODULES IS
EXPERIMENTAL. IT IS FINE IF THE PROJECT HAS BEEN MANUALLY SET UP TO BE
A GIT REPOSITORY WITH SUBMODULES: THIS FUNCTION WILL ONLY EVALUTE PATHS. This can
be set with the \code{option(SpaDES.project.useGit = xxx)}.}

\item{setLinuxBinaryRepo}{Logical. Should the binary RStudio Package Manager be used
on Linux (ignored if Windows)}

\item{standAlone}{A logical. Passed to \code{Require::standAlone}. This keeps all
packages installed in a project-level library, if \code{TRUE}. Default is \code{TRUE}.}

\item{libPaths}{Deprecated. Use \code{paths = list(packagePath = ...)}.}

\item{updateRprofile}{Logical. Should the \code{paths$packagePath} be set in the \code{.Rprofile}
file for this project. Note: if \code{paths$packagePath} is within the \code{tempdir()},
then there will be a warning, indicating this won't persist. If the user is
using \code{Rstudio} and the \code{paths$projectPath} is not the root of the current
Rstudio project, then a warning will be given, indicating the .Rprofile may not
be read upon restart.}

\item{overwrite}{Logical vector or character vector, however, only \code{getModule} will respond
to a vector of values. If length-one \code{TRUE}, then all files that were previously downloaded
will be overwritten throughout the sequence of \code{setupProject}. If a vector of
logical or character, these will be passed to \code{getModule}: only the named
modules will be overwritten or the logical vector of the modules.
NOTE: if a vector, no other file specified anywhere in \code{setupProject} will be
overwritten except a module that/those names, because
only \code{setupModules} is currently responsive to a vector. To have fine grained control,
a user can just manually delete a file, then rerun.}

\item{verbose}{Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if \code{1} or TRUE, more outputs; \code{2} even more. NOTE: in
\code{Require} function, when \code{verbose >= 2}, also returns details as if
\code{returnDetails = TRUE} (for backwards compatibility).}

\item{defaultDots}{A named list of any arbitrary R objects.
These can be supplied to give default values to objects that
are otherwise passed in with the \code{...}, i.e., not specifically named for these
\verb{setup*} functions. If named objects are supplied as top-level arguments, then
the \code{defaultDots} will be overridden. This can be particularly useful if the
arguments passed to \code{...} do not always exist, but rely on external e.g., batch
processing to optionally fill them. See examples.}

\item{envir}{The environment where \code{setupProject} is called from. Defaults to
\code{parent.frame()} which should be fine in most cases and user shouldn't need
to set this}

\item{dots}{Any other named objects passed as a list a user might want for other elements.}

\item{...}{further named arguments that acts like \code{objects}, but a different
way to specify them. These can be anything. The general use case
is to create the \code{objects} that are would be passed to
\code{SpaDES.core::simInit}, or \code{SpaDES.core::simInitAndSpades},
(e.g. \code{studyAreaName} or \code{objects}) or additional objects to be passed to the simulation
(in older versions of \code{SpaDES.core}, these were passed as a named list
to the \code{objects} argument). \strong{Order matters}. These are sequentially evaluated,
and also any arguments that are specified before the named arguments
e.g., \code{name}, \code{paths}, will be evaluated prior to any of the named arguments,
i.e., "at the start" of the \code{setupProject}.
If placed after the first named argument, then they will be evaluated at the
end of the \code{setupProject}, so can access all the packages, objects, etc.}
}
\value{
\code{setupProject} will return a named list with elements \code{modules}, \code{paths}, \code{params}, and \code{times}.
The goal of this list is to contain list elements that can be passed directly
to \code{simInit}.

It will also append all elements passed by the user in the \code{...}.
This list  can be passed directly to \code{SpaDES.core::simInit()} or
\code{SpaDES.core::simInitAndSpades()} using a \code{do.call()}. See example.

NOTE: both \code{projectPath} and \code{packagePath} will be omitted in the \code{paths} list
as they are used to set current directory (found with \code{getwd()}) and \code{.libPaths()[1]},
but are not accepted by \code{simInit}. \code{setupPaths} will still return these two paths as its
outputs are not expected to be passed directly to \code{simInit} (unlike \code{setupProject} outputs).
}
\description{
\code{setupProject} calls a sequence of functions in this order:
\code{setupOptions} (first time), \code{setupPaths}, \code{setupRestart},
\code{setupFunctions}, \code{setupModules}, \code{setupPackages}, \code{setupSideEffects},
\code{setupOptions} (second time), \code{setupParams}, and \code{setupGitIgnore}.

This sequence will create folder structures, install missing packages from those
listed in either the \code{packages}, \code{require} arguments or in the modules \code{reqdPkgs} fields,
load packages (only those in the \code{require} argument), set options, download or
confirm the existence of modules. It will also return elements that can be passed
directly to \code{simInit}  or \code{simInitAndSpades}, specifically, \code{modules}, \code{params},
\code{paths}, \code{times}, and any named elements passed to \code{...}. This function will also
, if desired, change the .Rprofile file for this project so that every time
the project is opened, it has a specific \code{.libPaths()}.

There are a number of convenience elements described in the section below. See Details.
Because of this sequence, users can take advantage of settings (i.e., objects)
that happen (are created) before others. For example, users can set \code{paths}
then use the \code{paths} list to set \code{options} that will can update/change \code{paths},
or set \code{times} and use the \code{times} list for certain entries in \code{params}.
}
\section{Faster runtime after project is set up}{


There are a number of checks that occur during \code{setupProject}. These take time, particularly
after an R restart (there is some caching in RAM that occurs, but this will only speed
things up if there is no restart of R). To get the "fastest", these options or settings
will speed things up, at the expense of not being completely re-runnable.
You can add one or more of these to the arguments. These will only be useful after a project
is set up, i.e., \code{setupProject} and \code{SpaDES.core::simInit} has/have been run at least once
to completion (so packages are installed).

\if{html}{\out{<div class="sourceCode">}}\preformatted{options = c(
  reproducible.useMemoise = TRUE,               # For caching, use memory objects
  Require.cloneFrom = Sys.getenv("R_LIBS_USER"),# Use personal library as possible source of packages
  spades.useRequire = FALSE,                    # Won't install packages/update versions
  spades.moduleCodeChecks = FALSE,              # moduleCodeChecks checks for metadata mismatches
  reproducible.inputPaths = "~/allData"),       # For sharing data files across projects
packages = NULL,                                # Prevents any packages installs with setupProject
useGit = FALSE                                  # Prevents checks using git
}\if{html}{\out{</div>}}

These will be set early in \code{setupProject}, so will affect the running of \code{setupProject}.
If the user manually sets one of these in addition to setting these, the user options will
override these.
The remining causes of \code{setupProject} being "slow" will be loading the required packages.

These options/arguments can now be set all at once
(with caution as these changes will affect how your
script will be run) with \code{options(SpaDES.project.fast = TRUE)} or in the \code{options} argument.
}

\section{Objective}{


The overarching objectives for these functions are:

\enumerate{
\item To prepare what is needed for \code{simInit}.
\item To help a user eliminate virtually all assignments to the \code{.GlobalEnv},
as these create and encourage spaghetti code that becomes unreproducible
as the project increases in complexity.
\item Be very simple for beginners, but powerful enough to expand to almost
any needs of arbitrarily complex projects, using the same structure
\item Deal with the complexities of R package installation and loading when
working with modules that may have been created by many users
\item Create a common SpaDES project structure, allowing
easy transition from one project to another, regardless of complexity.
}
}

\section{Convenience elements}{


\subsection{Sequential evaluation}{
Throughout these functions, efforts have been made to implement sequential evaluation,
within files and within lists. This means that a user can \emph{use} the values from an
upstream element in the list. For example, the following where \code{projectPath} is
part of the list that will be assigned to the \code{paths} argument and it is then
used in the subsequent list element is valid:

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupPaths(paths = list(projectPath = "here",
                        modulePath = file.path(paths[["projectPath"]], "modules")))
}\if{html}{\out{</div>}}

Because of such sequential evaluation, \code{paths}, \code{options}, and \code{params} files
can be sequential lists that have impose a hierarchy specified
by the order. For example, a user can first create a list of \emph{default} options,
then several lists of user-desired options behind an \verb{if (user("emcintir"))}
block that add new or override existing elements, followed by \code{machine} specific
values, such as paths.
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupOptions(
  maxMemory <- 5e+9 # if (grepl("LandWeb", runName)) 5e+12 else 5e+9

  # Example -- Use any arbitrary object that can be passed in the `...` of `setupOptions`
  #  or `setupProject`
  if (.mode == "development") \{
     list(test = 2)
  \}
  if (machine("A127")) \{
    list(test = 3)
  \}
)
}\if{html}{\out{</div>}}

\subsection{Values and/or files}{
The arguments, \code{paths}, \code{options}, and \code{params}, can all
understand lists of named values, character vectors, or a mixture by using a list where
named elements are values and unnamed elements are character strings/vectors. Any unnamed
character string/vector will be treated as a file path. If that file path has an \code{@} symbol,
it will be assumed to be a file that exists on a GitHub repository in \verb{https://github.com}.
So a user can pass values, or pointers to remote and/or local paths that themselves have values.

The following will set an option as declared, plus read the local file (with relative
path), plus download and read the cloud-hosted file.

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupProject(
   options = list(reproducible.useTerra = TRUE,
                  "inst/options.R",
                  "PredictiveEcology/SpaDES.project@transition/inst/options.R")
                 )
   )
}\if{html}{\out{</div>}}

This approach allows for an organic growth of complexity, e.g., a user begins with
only named lists of values, but then as the number of values increases, it may be
helpful to put some in an external file.

NOTE: if the GitHub repository is \emph{private} the user \emph{must} configure their GitHub
token by setting the GITHUB_PAT environment variable -- unfortunately, the \code{usethis}
approach to setting the token will not work at this moment.
}

\subsection{Specifying \code{paths}, \code{options}, \code{params}}{
If \code{paths}, \code{options}, and/or \code{params} are a character string
or character vector (or part of an unnamed list element) the string(s)
will be interpreted as files to parse. These files should contain R code that
specifies \emph{named lists}, where the names are one or more \code{paths}, \code{options},
or are module names, each with a named list of parameters for that named module.
This last named list for \code{params} follows the convention used for the \code{params} argument in
\code{simInit(..., params = )}.

These files can use \code{paths}, \code{times}, plus any previous list in the sequence of
\code{params} or \code{options} specified. Any functions that are used must be available,
e.g., prefixed \code{Require::normPath} if the package has not been loaded (as recommended).

If passing a file to \code{options}, it should \strong{not set} \code{options()} explicitly;
only create named lists. This enables options checking/validating
to occur within \code{setupOptions} and \code{setupParams}. A simplest case would be a file with this:
\code{opts <- list(reproducible.destinationPath = "~/destPath")}.

All named lists will be parsed into their own environment, and then will be
sequentially evaluated (i.e., subsequent lists will have access to previous lists),
with each named elements setting or replacing the previously named element of the same name,
creating a single list. This final list will be assigned to, e.g., \code{options()} inside \code{setupOptions}.

Because each list is parsed separately, they to not need to be assigned objects;
if they are, the object name can be any name, even if similar to another object's name
used to built the same argument's (i.e. \code{paths}, \code{params}, \code{options}) final list.
Hence, in an file to passed to \code{options}, instead of incrementing the list as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{a <- list(optA = 1)
b <- append(a, list(optB = 2))
c <- append(b, list(optC = 2.5))
d <- append(c, list(optD = 3))
}\if{html}{\out{</div>}}

one can do:

\if{html}{\out{<div class="sourceCode">}}\preformatted{a <- list(optA = 1)
a <- list(optB = 2)
c <- list(optC = 2.5)
list(optD = 3)
}\if{html}{\out{</div>}}

NOTE: only atomics (i.e., character, numeric, etc.), named lists, or either of these
that are protected by 1 level of "if" are parsed. This will not work, therefore,
for other side-effect elements, like authenticating with a cloud service.

Several helper functions exist within \code{SpaDES.project} that may be useful, such
as \code{user(...)}, \code{machine(...)}
}

\subsection{Can hard code arguments that may be missing}{
To allow for batch submission, a user can specify code \code{argument = value} even if \code{value}
is missing. This type of specification will not work in normal parsing of arguments,
but it is designed to work here. In the next example, \code{.mode = .mode} can be specified,
but if R cannot find \code{.mode} for the right hand side, it will just skip with no error.
Thus a user can source a script with the following line from batch script where \code{.mode}
is specified. When running this line without that batch script specification, then this
will assign no value to \code{.mode}. We include \code{.nodes} which shows an example of
passing a value that does exist. The non-existent \code{.mode} will be returned in the \code{out},
but as an unevaluated, captured list element.

\if{html}{\out{<div class="sourceCode">}}\preformatted{.nodes <- 2
out <- setupProject(.mode = .mode,
                    .nodes = .nodes,
                    options = "inst/options.R"
                    )
}\if{html}{\out{</div>}}

}
}

\examples{
## For more examples:
vignette("i-getting-started", package = "SpaDES.project")

library(SpaDES.project)

\dontshow{origDir <- getwd()
          tmpdir <- Require::tempdir2() # for testing tempdir2 is better}
\dontshow{
if (is.null(getOption("repos"))) {
  options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  setwd(tmpdir)
}
 ## simplest case; just creates folders
out <- setupProject(
  paths = list(projectPath = ".") #
)
\dontshow{setwd(origDir)}
}
\seealso{
\code{\link[=setupPaths]{setupPaths()}}, \code{\link[=setupOptions]{setupOptions()}}, \code{\link[=setupPackages]{setupPackages()}},
\code{\link[=setupModules]{setupModules()}}, \code{\link[=setupGitIgnore]{setupGitIgnore()}}. Also, helpful functions such as
\code{\link[=user]{user()}}, \code{\link[=machine]{machine()}}, \code{\link[=node]{node()}}

\code{vignette("i-getting-started", package = "SpaDES.project")}
}
