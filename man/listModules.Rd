% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/listModules.R
\name{listModules}
\alias{listModules}
\alias{moduleDependencies}
\alias{moduleDependenciesToGraph}
\alias{PlotModuleGraph}
\title{Tools for examining modules on known repositories}
\usage{
listModules(
  keywords,
  accounts,
  omit = c("fireSense_dataPrepFitRas"),
  purge = FALSE,
  verbose = getOption("Require.verbose", 1L)
)

moduleDependencies(modules, modulePath)

moduleDependenciesToGraph(md)

PlotModuleGraph(graph)
}
\arguments{
\item{keywords}{A vector of character strings that will be used as keywords for identify
modules}

\item{accounts}{A vector of character strings identifying GitHub accounts e.g.,
\code{PredictiveEcology} to search.}

\item{omit}{A vector of character strings of repositories to ignore.}

\item{purge}{There is some internal caching that occurs. Setting this to \code{TRUE} will
remove any cached data that is part of the requested \code{accounts} and \code{keywords}.}

\item{verbose}{Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if \code{1} or TRUE, more outputs; \code{2} even more. NOTE: in
\code{Require} function, when \code{verbose >= 2}, the return object will have an
attribute: \code{attr(.., "Require")} which has lots of information about the
processes of the installs.}

\item{modules}{A named list of character strings of full module names, as returned
by \code{listModules}.}

\item{modulePath}{A character string indicating the path where the modules
are located.}

\item{md}{A data.table with columns \code{from} and \code{to}, showing relationships of
objects in modules. Likely from \code{moduleDependencies}.}

\item{graph}{An igraph object to plot. Likely returned by \code{moduleDependenciesToGraph}.}
}
\value{
\code{listModules} returns a named list of all SpaDES modules in the given repositories with
the \code{accounts} and \code{keywords} provided.
}
\description{
When exploring existing modules, these tools help identify and navigate modules
and their interdependencies.
}
\examples{

\donttest{
library(reproducible)
mods <- Cache(listModules, c("Biomass", "WBI", "LandR", "fireSense", "CBM",
                             "LandMine", "LandWeb", "NRV", #"scfm",
                             "priority",
                             "dataPrep", "DataPrep", "RoF", "Ontario", "ROF"),
              accounts = c("PredictiveEcology", "ianmseddy", "achubaty",
                           "FOR-CAST", "eliotmcintire", "tati-micheletti"))

modPath <- file.path(tempdir(), "testMods")
out <- Map(mod = mods, nam = names(mods), function(mod, nam) {
       out <- getModule(paste0(nam, "/", mod),
       modulePath = modPath)
       out
})

DT <- moduleDependencies(mods, modulePath = modPath)
graph <- moduleDependenciesToGraph(DT)
vn <- PlotModuleGraph(graph)

# get all the fireSense modules from the Predictive Ecology GitHub repository
Account <- "PredictiveEcology"
mods <- listModules("fireSense", Account)
out <- setupProject(modules = file.path(Account, mods[[Account]]),
                    paths = list(projectPath = "~/fireSense"))
}
}
